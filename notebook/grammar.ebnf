program ::= '[sourceFile]'
sourceFile ::= '[sourceUnit*]'
sourceUnit ::= '[pragmaDirective]' | '[ImportDirective]' | '[ContractDefinition]'
pragmaDirective ::= pragmaValue ::= '[repeat AttributeOrVersion]'
AttributeOrVersion ::= '[version]' | version ::= '[versionConstraint]'
versionOperator ::= versionConstraint ::= '[opt versionOperator]' '[VersionLiteral]'
VersionLiteral ::= '[number+]'
ImportDirective ::= '[ImportLine1]' | ImportLine1 ::= ImportLine2 ::= ImportLine3 ::= IdOptAsIdentifier ::= '[id]' '[opt asIdentifier]'
asIdentifier ::= stericIdentifier ::= OptionalIdentifer ::= ContractDefinition ::= '[ContractKeywords]' '[id]' '[opt IsInheritenceSpecifier]' | '[ContractBody*]' '[EX]' | ContractKeywords ::= IsInheritenceSpecifier ::= InheritanceSpecifier ::= '[UserDefinedTypeName]' '[opt InternalInheritenceSpecifier]'
InternalInheritenceSpecifier ::= UserDefinedTypeName ::= '[id]' '[IdWithDot*]'
IdWithDot ::= Expression ::= '[PrimaryExpression]' | NewExpression ::= QuestionSelectExpression ::= '[Expression]' '? '[Expression]' ': '[Expression]'
LogicalAndExpression ::= '[Expression]' '&& '[Expression]'
OrExpression ::= '[Expression]' '| '[Expression]'
XorExpression ::= '[Expression]' '^ '[Expression]'
AndExpression ::= '[Expression]' '& '[Expression]'
LogicalOrExpression ::= '[Expression]' '|'| '[Expression]'
ShiftLeftShiftRight ::= '[Expression]' '[ShiftLeftShiftRightInternal]' '[Expression]'
ShiftLeftShiftRightInternal ::= PlusMinusExpression ::= '[Expression]' '[PlusMinusInternal]' '[Expression]'
PlusMinusInternal ::= MultiplicationDivision ::= '[Expression]' '[MultiplcationDivisionInternal]' '[Expression]'
MultiplcationDivisionInternal ::= DoublePointerExpression ::= '[Expression]' '** '[Expression]'
UnaryExpression ::= '[UnaryInternal]' '[Expression]'
UnaryInternal ::= LessThanGreaterThan ::= '[Expression]' '[LessThanInternal]' '[Expression]'
LessThanInternal ::= IndexAccess ::= '[Expression]'''['[opt Expression]'']'
ExpressionWithParenthesis ::= BooleanEqualNotEqualExpression ::= '[Expression]' '[internalEqualNotEqual]' '[Expression]'
internalEqualNotEqual ::= MemberAccess ::= '[Expression]' '. '[id]'
post_inc_dec ::= ExpressionPostIncrement ::= '[Expression]''[post_inc_dec]'
AssignmentOptions ::= '[Expression]' '[EqualExpressionInternal]' '[Expression]'
EqualExpressionInternal ::= PrimaryExpression ::= '[BooleanLiteral]' | TupleExpression ::= TupleElement ::= '[Expression?]'
BooleanLiteral ::= NumberLiteral ::= '[NumberInternal]' '[opt NumberUnit]'
HexLiteral ::= ElementaryTypeNameExpression ::= '[ElementaryTypeName]'
NumberUnit ::= NumberInternal ::= '[solidity_hex_number]' | '[number]'
TypeName ::= '[ElementaryTypeName]' | AddressPayable ::= ElementaryTypeName ::= Mapping ::= ArrayTypeName ::= '[TypeName]' ''[ '[opt Expression]' ']'
FunctionTypeName ::= FunctionReturn ::= FunctionTypeParameterList ::= FunctionTypeParameter ::= '[TypeName]' '[opt StorageLocation]'
StorageLocation ::= FunctionExposure ::= StateMutability ::= Int ::= Uint ::= Byte ::= Fixed ::= Ufixed ::= ContractBody ::= '[StateVariableDeclaration]' | '[UsingForDeclaration]' | StateVariableDeclaration ::= '[TypeName]' '[StateKeywords*]' '[id]' '[opt ExpressionWithEqualSign]' '; '[NL]'
StateKeywords ::= UsingForDeclaration ::= StericTypeName ::= StructDefinition ::= '[VariableDeclarationMeta+]' '[EX]' | ConstructorDefinition ::= VariableDeclarationMeta ::= '[VariableDeclaration]' '; '[NL]'
VariableDeclaration ::= '[TypeName]' '[opt StorageLocation]' '[id]'
ModifierDefinition ::= FunctionDefinition ::= '[FunctionalDefinitionInternalModifiers*]' | '[opt OptionalReturnBlock]' '[FunctionInternalEndBlock]'
FunctionInternalEndBlock ::= OptionalReturnBlock ::= FunctionalDefinitionInternalModifiers ::= '[ModifierInvocation]' | '[StateMutability]' | 'external | 'public | 'internal | 'private
EventDefinition ::= EventParameterList ::= EventParameter ::= '[TypedEventParameter?]'
TypedEventParameter ::= '[TypeName]' '[opt 'indexed]' '[opt id]'
EnumDefinition ::= CommaSeparatedEnumValues ::= '[EnumValue,+]'
EnumValue ::= '[id]'
ModifierInvocation ::= '[id]' '[opt OptionalModifierInvocation]'
OptionalModifierInvocation ::= ParameterList ::= Parameter ::= '[TypedParameter?]'
TypedParameter ::= '[TypeName]' '[opt StorageLocation]' '[opt id]'
Block ::= '[Statement*]' '[EX]' | Statement ::= '[IfStatement]' | '[WhileStatement]' | '[ForStatement]' | '[Block]' | '[InlineAssemblyStatement]' | CombineSemicolon ::= '[StatementThatNeedSemicolon]' '; '[NL]'
StatementThatNeedSemicolon ::= '[Require]' | '[DoWhileStatement]' | '[PlaceholderStatement]' | '[Continue]' | '[Break]' | IfStatement ::= ElseStatement ::= WhileStatement ::= ForStatement ::= SimpleStatement ::= '[VariableDefinition]' | '[ExpressionStatement]'
VariableDefinition ::= '[InternatlVariableDefinition]' '[opt ExpressionWithEqualSign]'
ExpressionWithEqualSign ::= InternatlVariableDefinition ::= '[VariableDeclaration]' | '[VariableDeclarationWithParenthesis]'
VariableDeclarationWithParenthesis ::= OptVariableDeclaration ::= '[VariableDeclaration?]'
ExpressionStatement ::= '[Expression]'
DoWhileStatement ::= InlineAssemblyStatement ::= PlaceholderStatement ::= Continue ::= Break ::= Require ::= Return ::= Throw ::= EmitStatement ::= FunctionCall ::= '[Expression]' '( '[FunctionCallArguments]' ')
FunctionCallArguments ::= '[NamedValueWithBraces]' | '[opt ExpressionList]'
NamedValueWithBraces ::= NameValueList ::= '[InlineNamedValue,+]'
InlineNamedValue ::= '[id]' ': '[Expression]'
ExpressionList ::= '[Expression,+]'
AssemblyBlock ::= '[AssemblyStatement*]' '[EX]' | AssemblyStatement ::= '[AssemblyFunctionDefinition]' | AssemblyFunctionDefinition ::= '[opt OptionlInlineAssembly]' '[AssemblyBlock]'
OptionlInlineAssembly ::= AssemblyVariableDeclaration ::= OptionalAssemblyVaribale ::= AssemblyAssignment ::= '[AssemblyIdentifierList]' ':= '[AssemblyExpression]'
AssemblyExpression ::= '[AssemblyFunctionCall]' | '[id]' | '[Literal]'
AssemblyIf ::= AssemblyIfConditions ::= '[id]' | '[Literal]'
AssemblySwitch ::= AssemblySwitchConditions ::= '[id]' | '[Literal]'
InlineAssemblySwitch ::= '[InlineInlineAssemblySwitch]' | '[AssemblyDefault]'
InlineInlineAssemblySwitch ::= '[AssemblyCase+]' '[opt AssemblyDefault]'
AssemblyCase ::= AssemblyDefault ::= AssemblyForLoop ::= AssemblyBreakContinue ::= AssemblyFunctionCall ::= '[id]''( '[opt InlineOptinonalAssemblyFunctionCall]' ')
InlineOptinonalAssemblyFunctionCall ::= '[AssemblyExpression,+]'
AssemblyIdentifierList ::= '[id,+]'
StringLiteral ::= '[stringlit]' | Literal ::= '[NumberLiteral]' | 